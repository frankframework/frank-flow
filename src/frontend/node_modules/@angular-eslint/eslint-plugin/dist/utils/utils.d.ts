import type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';
export declare const objectKeys: <T>(o: T) => readonly Extract<keyof T, string>[];
export declare enum AngularClassDecorators {
    Component = "Component",
    Directive = "Directive",
    Injectable = "Injectable",
    NgModule = "NgModule",
    Pipe = "Pipe"
}
declare enum AngularConstructorParameterDecorators {
    Attribute = "Attribute",
    Host = "Host",
    Inject = "Inject",
    Optional = "Optional",
    Self = "Self",
    SkipSelf = "SkipSelf"
}
declare enum AngularMethodDecorators {
    HostListener = "HostListener"
}
declare enum AngularPropertyAccessorDecorators {
    ContentChild = "ContentChild",
    ContentChildren = "ContentChildren",
    HostBinding = "HostBinding",
    Input = "Input",
    Output = "Output",
    ViewChild = "ViewChild",
    ViewChildren = "ViewChildren"
}
export declare const AngularInnerClassDecorators: {
    ContentChild: AngularPropertyAccessorDecorators.ContentChild;
    ContentChildren: AngularPropertyAccessorDecorators.ContentChildren;
    HostBinding: AngularPropertyAccessorDecorators.HostBinding;
    Input: AngularPropertyAccessorDecorators.Input;
    Output: AngularPropertyAccessorDecorators.Output;
    ViewChild: AngularPropertyAccessorDecorators.ViewChild;
    ViewChildren: AngularPropertyAccessorDecorators.ViewChildren;
    HostListener: AngularMethodDecorators.HostListener;
    Attribute: AngularConstructorParameterDecorators.Attribute;
    Host: AngularConstructorParameterDecorators.Host;
    Inject: AngularConstructorParameterDecorators.Inject;
    Optional: AngularConstructorParameterDecorators.Optional;
    Self: AngularConstructorParameterDecorators.Self;
    SkipSelf: AngularConstructorParameterDecorators.SkipSelf;
};
export declare enum AngularLifecycleInterfaces {
    AfterContentChecked = "AfterContentChecked",
    AfterContentInit = "AfterContentInit",
    AfterViewChecked = "AfterViewChecked",
    AfterViewInit = "AfterViewInit",
    DoBootstrap = "DoBootstrap",
    DoCheck = "DoCheck",
    OnChanges = "OnChanges",
    OnDestroy = "OnDestroy",
    OnInit = "OnInit"
}
export declare enum AngularLifecycleMethods {
    ngAfterContentChecked = "ngAfterContentChecked",
    ngAfterContentInit = "ngAfterContentInit",
    ngAfterViewChecked = "ngAfterViewChecked",
    ngAfterViewInit = "ngAfterViewInit",
    ngDoBootstrap = "ngDoBootstrap",
    ngDoCheck = "ngDoCheck",
    ngOnChanges = "ngOnChanges",
    ngOnDestroy = "ngOnDestroy",
    ngOnInit = "ngOnInit"
}
export declare const OPTION_STYLE_CAMEL_CASE = "camelCase";
export declare const OPTION_STYLE_KEBAB_CASE = "kebab-case";
export declare type SelectorStyle = typeof OPTION_STYLE_CAMEL_CASE | typeof OPTION_STYLE_KEBAB_CASE;
export declare type AngularClassDecoratorKeys = keyof typeof AngularClassDecorators;
export declare type AngularInnerClassDecoratorKeys = Exclude<keyof typeof AngularInnerClassDecorators, number>;
export declare type AngularLifecycleInterfaceKeys = keyof typeof AngularLifecycleInterfaces;
export declare type AngularLifecycleMethodKeys = keyof typeof AngularLifecycleMethods;
export declare const angularClassDecoratorKeys: readonly ("Component" | "Directive" | "Injectable" | "NgModule" | "Pipe")[];
export declare const angularInnerClassDecoratorKeys: readonly ("ContentChild" | "ContentChildren" | "HostBinding" | "Input" | "Output" | "ViewChild" | "ViewChildren" | "HostListener" | "Attribute" | "Host" | "Inject" | "Optional" | "Self" | "SkipSelf")[];
export declare const angularLifecycleInterfaceKeys: readonly ("AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "DoBootstrap" | "DoCheck" | "OnChanges" | "OnDestroy" | "OnInit")[];
export declare const angularLifecycleMethodKeys: readonly ("ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngDoBootstrap" | "ngDoCheck" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit")[];
export declare const ANGULAR_CLASS_DECORATOR_LIFECYCLE_METHOD_MAPPER: ReadonlyMap<AngularClassDecoratorKeys, ReadonlySet<AngularLifecycleMethodKeys>>;
export declare const ANGULAR_INNER_CLASS_DECORATORS: ReadonlySet<AngularInnerClassDecoratorKeys>;
export declare const ANGULAR_CLASS_DECORATORS: ReadonlySet<AngularClassDecoratorKeys>;
export declare const ANGULAR_CLASS_DECORATOR_MAPPER: ReadonlyMap<AngularClassDecoratorKeys, ReadonlySet<AngularInnerClassDecoratorKeys>>;
/**
 * SECTION START:
 * Equivalents of utils exported by TypeScript itself for its own AST
 */
export declare function isCallExpression(node: TSESTree.Node): node is TSESTree.CallExpression;
export declare function isMemberExpression(node: TSESTree.Node): node is TSESTree.MemberExpression;
export declare function isClassDeclaration(node: TSESTree.Node): node is TSESTree.ClassDeclaration;
export declare function isObjectExpression(node: TSESTree.Node): node is TSESTree.ObjectExpression;
export declare function isArrayExpression(node: TSESTree.Node): node is TSESTree.ArrayExpression;
export declare function isProperty(node: TSESTree.Node): node is TSESTree.Property;
export declare function isLiteral(node: TSESTree.Node): node is TSESTree.Literal;
export declare function isTemplateLiteral(node: TSESTree.Node): node is TSESTree.TemplateLiteral;
export declare function isImportDeclaration(node: TSESTree.Node): node is TSESTree.ImportDeclaration;
declare type LiteralWithStringValue = TSESTree.Literal & {
    value: string;
};
/**
 * ESTree does not differentiate between different types of Literals at the AST level,
 * but it is a common thing to need to do, so this utility and interface are here to
 * avoid repeated typeof checks on the node's value.
 */
export declare function isLiteralWithStringValue(node: TSESTree.Node): node is LiteralWithStringValue;
export declare function isMethodDefinition(node: TSESTree.Node): node is TSESTree.MethodDefinition;
export declare function isSuper(node: TSESTree.Node): node is TSESTree.Super;
/**
 * SECTION END:
 * Equivalents of utils exported by TypeScript itself for its own AST
 */
export declare function getNearestNodeFrom<T extends TSESTree.Node>({ parent }: TSESTree.Node, predicate: (parent: TSESTree.Node) => parent is T): T | null;
export declare function getImportDeclarations(node: TSESTree.Node, moduleName: string): readonly TSESTree.ImportDeclaration[] | undefined;
export declare function getImplementsRemoveFix(sourceCode: Readonly<TSESLint.SourceCode>, classDeclaration: TSESTree.ClassDeclaration, interfaceName: string, fixer: TSESLint.RuleFixer): TSESLint.RuleFix | undefined;
export declare function getNodeToCommaRemoveFix(sourceCode: Readonly<TSESLint.SourceCode>, node: TSESTree.Node, fixer: TSESLint.RuleFixer): TSESLint.RuleFix;
export declare function getLast<T extends readonly unknown[]>(items: T): T[number];
export declare function getImportAddFix(node: TSESTree.ClassDeclaration, moduleName: string, importedName: string, fixer: TSESLint.RuleFixer): TSESLint.RuleFix;
export declare function getImportRemoveFix(sourceCode: Readonly<TSESLint.SourceCode>, importDeclarations: readonly TSESTree.ImportDeclaration[], importedName: string, fixer: TSESLint.RuleFixer): TSESLint.RuleFix | undefined;
export declare function getImplementsSchemaFixer({ id, implements: implementz }: TSESTree.ClassDeclaration, interfaceName: string): {
    readonly implementsNodeReplace: TSESTree.TSClassImplements | TSESTree.Identifier;
    readonly implementsTextReplace: string;
};
export declare const getClassName: (node: TSESTree.Node) => string | undefined;
export declare const getDecorator: (node: TSESTree.ClassDeclaration, decoratorName: string) => TSESTree.Decorator | undefined;
export declare const getAngularClassDecorator: ({ decorators, }: TSESTree.ClassDeclaration) => AngularClassDecoratorKeys | undefined;
export declare const getDecoratorArgument: ({ expression, }: TSESTree.Decorator) => TSESTree.ObjectExpression | undefined;
export declare const getDecoratorName: ({ expression, }: TSESTree.Decorator) => string | undefined;
export declare const getPipeDecorator: (node: TSESTree.ClassDeclaration) => TSESTree.Decorator | undefined;
export declare const getDeclaredInterfaces: (node: TSESTree.ClassDeclaration) => TSESTree.TSClassImplements[];
export declare const getDeclaredInterfaceNames: (node: TSESTree.ClassDeclaration) => readonly string[];
export declare const getDeclaredInterfaceName: (node: TSESTree.ClassDeclaration, value: string) => string | undefined;
export declare const getDeclaredAngularLifecycleInterfaces: (node: TSESTree.ClassDeclaration) => readonly AngularLifecycleInterfaceKeys[];
export declare const getDeclaredAngularLifecycleMethods: (node: TSESTree.ClassDeclaration) => readonly AngularLifecycleMethodKeys[];
export declare const ANGULAR_LIFECYCLE_INTERFACES: ReadonlySet<AngularLifecycleInterfaceKeys>;
export declare const ANGULAR_LIFECYCLE_METHODS: ReadonlySet<AngularLifecycleMethodKeys>;
export declare const isAngularLifecycleInterface: (value: string) => value is "AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "DoBootstrap" | "DoCheck" | "OnChanges" | "OnDestroy" | "OnInit";
export declare const isAngularLifecycleMethod: (value: string) => value is "ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngDoBootstrap" | "ngDoCheck" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit";
export declare const isAngularClassDecorator: (value: string) => value is "Component" | "Directive" | "Injectable" | "NgModule" | "Pipe";
export declare const isAngularInnerClassDecorator: (value: string) => value is AngularInnerClassDecoratorKeys;
/**
 * `ClassProperty` nodes can have different types of `key`s
 *
 * E.g.
 *
 * class Foo {
 *  a // Identifier
 * 'b' // Literal
 *  ['c'] // Literal
 * }
 */
export declare function getClassPropertyName({ key }: TSESTree.ClassProperty): string;
export declare const getDecoratorProperty: (decorator: TSESTree.Decorator, name: string) => TSESTree.Property | undefined;
export declare const getDecoratorPropertyValue: (decorator: TSESTree.Decorator, name: string) => TSESTree.Property['value'] | undefined;
export declare const getDeclaredMethods: ({ body: { body }, }: TSESTree.ClassDeclaration) => readonly TSESTree.MethodDefinition[];
export declare const getMethodName: (node: TSESTree.MethodDefinition) => string | undefined;
export declare const getLifecycleInterfaceByMethodName: (methodName: AngularLifecycleMethodKeys) => AngularLifecycleInterfaceKeys;
/**
 * Enforces the invariant that the input is an array.
 */
export declare function arrayify<T>(arg?: T | readonly T[]): readonly T[];
export declare const isNotNullOrUndefined: <T>(input: T | null | undefined) => input is T;
export declare const SelectorValidator: {
    attribute(selector: string): boolean;
    camelCase(selector: string): boolean;
    element(selector: string): boolean;
    kebabCase(selector: string): boolean;
    prefix(prefix: string, selectorStyle: SelectorStyle): (selector: string) => boolean;
};
export declare const kebabToCamelCase: (value: string) => string;
export declare function isImportedFrom(identifier: TSESTree.Identifier, moduleName: string): boolean;
/**
 * Convert an array to human-readable text.
 */
export declare const toHumanReadableText: (items: readonly string[]) => string;
export declare const toPattern: (value: readonly unknown[]) => RegExp;
export {};
